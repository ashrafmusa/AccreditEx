# FIREBASE FREE TIER - DEVELOPER DECISION TREE
**Quick Reference for Implementation Choices**

---

## ðŸ¤” WHEN TO PAGINATE VS FILTER VS CACHE

### Question 1: Is this a collection the user sees as a list?
```
YES â†’ Use PAGINATION (userList, projectList, documentList)
      âœ“ Break into 25-item pages
      âœ“ "Load More" or infinite scroll UI
      
NO â†’ Use FILTERING (getting users by role, projects by status)
     âœ“ Add where() clause to query
     âœ“ Fetch only needed subset
```

### Question 2: Does the user access this data repeatedly?
```
YES â†’ Use CACHING (user profile, app settings, standard lists)
      âœ“ Cache for 5 minutes
      âœ“ Invalidate on mutations
      âœ“ Clear on logout
      
NO â†’ No caching needed (one-time reads)
     âœ“ Still use pagination/filtering
     âœ“ But don't cache the result
```

### Question 3: Does this data need real-time updates?
```
YES â†’ Use LISTENER (dashboard stats, project status, task changes)
      âœ“ Single listener in store
      âœ“ All components subscribe to store
      âœ“ Automatic updates on any change
      
NO â†’ Use QUERY (search results, reports, historical data)
     âœ“ Fetch once
     âœ“ Use pagination if large
     âœ“ Cache if accessed frequently
```

---

## ðŸ“‹ DECISION MATRIX

| Feature | Pagination | Filtering | Caching | Listener |
|---------|-----------|-----------|---------|----------|
| **When** | List views | Specific subset | Repeated access | Live data |
| **Example** | Users page | Active projects | User profile | Dashboard |
| **Read Cost** | Low (25 items) | Low (subset only) | Zero (if cached) | Per change |
| **Implementation** | Medium | Easy | Medium | Hard |
| **Code Location** | Service | Service | Service | Store |
| **Invalidation** | N/A | N/A | On mutation | Automatic |

---

## ðŸ› ï¸ IMPLEMENTATION BY USE CASE

### USE CASE 1: User List Page
```
Requirements:
- Display 100+ users in a list
- Ability to search/filter
- Good performance with many users

Implementation:
1. getPaginatedUsers(pageSize=25, lastDoc) â†’ Pagination
2. getActiveUsers() â†’ Filtering (show only active)
3. Cache results for 5 min
4. Use infinite scroll or "Load More" button

Code Pattern:
const { users, lastDoc, hasMore } = await getActiveUsers(25);
if (hasMore) {
    const next = await getActiveUsers(25, lastDoc);
}
```

---

### USE CASE 2: Project Detail Page
```
Requirements:
- Show single project with full details
- Quick access to related data
- Real-time updates on changes

Implementation:
1. getProjectById(id) â†’ Single doc fetch (fast, 1 read)
2. Cache for 5 min (or until mutation)
3. Listen to project document for real-time updates
4. Listen to related documents (tasks, documents) separately

Code Pattern:
const project = useProjectStore(state => state.selectedProject);
useEffect(() => {
    const unsub = onSnapshot(doc(projectsCollection, id), (snap) => {
        store.setSelectedProject(snap.data());
    });
    return unsub;
}, [id]);
```

---

### USE CASE 3: Dashboard Statistics
```
Requirements:
- Show live counts/stats
- Update when data changes
- Good performance with many queries

Implementation:
1. Single listener on collections
2. Store aggregates the counts
3. All dashboard widgets read from store
4. Real-time updates automatic

Code Pattern:
// In store
const unsubscribe = onSnapshot(projectsCollection, (snap) => {
    const total = snap.size;
    const active = snap.docs.filter(d => d.data().status === 'Active').length;
    set({ projectCount: total, activeProjects: active });
});

// In component
const stats = useDashboardStore(state => ({
    projectCount: state.projectCount,
    activeProjects: state.activeProjects
}));
```

---

### USE CASE 4: Search/Filter Modal
```
Requirements:
- Filter large collection by multiple criteria
- User can type to search
- Fast response

Implementation:
1. Database filtering with where() clauses
2. Multiple filters combined (AND logic)
3. No pagination needed (filtered set is small)
4. Cache results while modal is open

Code Pattern:
const q = query(
    projectsCollection,
    where("status", "==", "Active"),
    where("departmentId", "==", selectedDept),
    where("name", ">=", searchText),
    where("name", "<=", searchText + "\uf8ff"),
    limit(100)
);
const results = await getDocs(q);
```

---

### USE CASE 5: Bulk Operations
```
Requirements:
- Update many documents
- Efficient writes
- Transaction safety

Implementation:
1. Batch writes (max 500 per batch)
2. No pagination needed
3. Wrap in transaction for safety
4. Invalidate cache after

Code Pattern:
const batch = writeBatch(db);
selectedUsers.forEach(user => {
    const userRef = doc(usersCollection, user.id);
    batch.update(userRef, { status: "Inactive" });
});
await batch.commit();
cacheService.invalidate('users');
```

---

## ðŸš¨ ANTI-PATTERNS (Don't Do This)

### âŒ ANTI-PATTERN 1: Fetch All, Filter Client-Side
```typescript
// âŒ BAD: Fetches all 1000 docs, filters in JavaScript
const allDocs = await getDocs(documentsCollection);
const activeOnly = allDocs.filter(d => d.status === 'Active');

// âœ… GOOD: Fetches only active docs
const q = query(documentsCollection, where("status", "==", "Active"));
const activeOnly = await getDocs(q);
// Cost: 50 reads vs 1000 reads
```

### âŒ ANTI-PATTERN 2: Duplicate Listeners
```typescript
// âŒ BAD: Multiple components, multiple listeners
function Component1() {
    useEffect(() => {
        const unsub = onSnapshot(projectsCollection, /* ... */);
        return unsub;
    }, []);
}

function Component2() {
    useEffect(() => {
        const unsub = onSnapshot(projectsCollection, /* ... */); // DUPLICATE!
        return unsub;
    }, []);
}

// âœ… GOOD: Single listener in store
const useProjectStore = create(() => {
    useEffect(() => {
        const unsub = onSnapshot(projectsCollection, /* ... */);
        return unsub;
    }, []);
});

function Component1() {
    const projects = useProjectStore(state => state.projects);
}

function Component2() {
    const projects = useProjectStore(state => state.projects);
}
```

### âŒ ANTI-PATTERN 3: No Pagination
```typescript
// âŒ BAD: Fetches all items, even if not displayed
const allItems = await getDocs(itemsCollection); // Maybe 10K items
// Costs: 10K reads, slow page load, memory issues

// âœ… GOOD: Fetch only what's visible
const q = query(itemsCollection, limit(25));
const items = await getDocs(q); // 25 reads, fast, efficient
```

### âŒ ANTI-PATTERN 4: Forget to Clean Up Listeners
```typescript
// âŒ BAD: Listener never unsubscribed (memory leak + costs)
useEffect(() => {
    onSnapshot(projectsCollection, (snap) => {
        setProjects(snap.docs);
    });
    // Missing: return unsubscribe function!
}, []);

// âœ… GOOD: Clean up listener
useEffect(() => {
    const unsub = onSnapshot(projectsCollection, (snap) => {
        setProjects(snap.docs);
    });
    return () => unsub(); // IMPORTANT!
}, []);
```

---

## ðŸŽ¯ QUICK REFERENCE CHECKLIST

### Before Writing a Query

- [ ] **Is this a list?** â†’ Use pagination (limit 25)
- [ ] **Fetch specific subset?** â†’ Use where() filters
- [ ] **Accessed repeatedly?** â†’ Use caching (5 min TTL)
- [ ] **Need real-time updates?** â†’ Use listener (in store, not component)
- [ ] **Combining multiple filters?** â†’ Use AND conditions, not separate queries
- [ ] **Sorting needed?** â†’ Use orderBy() at DB level, not client-side
- [ ] **Need total count?** â†’ Query with limit anyway, then add count query
- [ ] **Paging through results?** â†’ Use startAfter(lastDoc) with limit

### After Writing a Query

- [ ] **Query has explicit limit()** âœ“
- [ ] **Using where() when possible** âœ“
- [ ] **Listener is in store (if needed)** âœ“
- [ ] **Component uses store listener (not own listener)** âœ“
- [ ] **Cache invalidation on mutation** âœ“
- [ ] **Error handling in place** âœ“
- [ ] **Loading states handled** âœ“
- [ ] **No console warnings** âœ“

---

## ðŸ“Š QUICK COST CALCULATOR

### How many reads per operation?

```
getDocs(collection) = 1 read per document
    Example: 100 users = 100 reads

getDocs(query(collection, limit(25))) = 1 read per document in result
    Example: Paginated query = 25 reads

getDocs(query(collection, where(...))) = 1 read per matching document
    Example: Filter 100 docs to 20 = 20 reads

onSnapshot(collection) = 1 read per document FIRST TIME
    Then 0 reads for updates (just sends changes)
    Example: 100 docs = 100 reads once, then free updates

Query with no results = 0 reads
    Example: where("id", "==", "nonexistent") = 0 reads
```

### Worst Case (What to Avoid)
```
getDocs(allUsersCollection) = 10,000 reads (all users)
Ã— onLoad + onRefresh = 20,000 reads/day
Ã— 5 components doing same thing = 100,000 reads/day
= EXCEEDS FREE TIER

Cost: $60/month
Solution: Use pagination + 1 listener = 5,000 reads/day
Result: FREE
```

---

## ðŸ¤– RULE OF THUMB

**For every query, ask:**
1. "Can I limit the results?" â†’ Add `limit()`
2. "Can I filter at database?" â†’ Add `where()`
3. "Will users access this repeatedly?" â†’ Add `cache()`
4. "Do multiple components need this?" â†’ Move to `store`
5. "Does this need real-time?" â†’ Use `onSnapshot()` in store only

**If ALL questions = YES:** You have an optimal query

---

## ðŸ“š CODE SNIPPETS BY USE CASE

### List View with Pagination
```typescript
export const useUsersPage = () => {
    const [users, setUsers] = useState<User[]>([]);
    const [lastDoc, setLastDoc] = useState<QueryDocumentSnapshot | null>(null);
    const [hasMore, setHasMore] = useState(true);

    const loadMore = async () => {
        const q = query(usersCollection, limit(26), startAfter(lastDoc || 0));
        const snap = await getDocs(q);
        
        const newUsers = snap.docs.slice(0, 25).map(doc => doc.data());
        setUsers(prev => [...prev, ...newUsers]);
        setLastDoc(snap.docs[24]);
        setHasMore(snap.docs.length > 25);
    };

    useEffect(() => {
        loadMore(); // Initial load
    }, []);

    return { users, hasMore, loadMore };
};
```

### Detail View with Real-time Updates
```typescript
export const useProjectDetail = (projectId: string) => {
    const [project, setProject] = useState<Project | null>(null);

    useEffect(() => {
        const projectRef = doc(projectsCollection, projectId);
        const unsub = onSnapshot(projectRef, (snap) => {
            if (snap.exists()) {
                setProject(snap.data() as Project);
            }
        });

        return unsub;
    }, [projectId]);

    return project;
};
```

### Filtered Search with Caching
```typescript
const cache = new Map<string, any>();

export const searchProjects = async (searchText: string) => {
    const cacheKey = `search_${searchText}`;
    
    if (cache.has(cacheKey)) {
        return cache.get(cacheKey);
    }

    const q = query(
        projectsCollection,
        where("name", ">=", searchText),
        where("name", "<=", searchText + "\uf8ff"),
        limit(50)
    );
    
    const snap = await getDocs(q);
    const results = snap.docs.map(doc => doc.data());
    
    cache.set(cacheKey, results);
    setTimeout(() => cache.delete(cacheKey), 5 * 60 * 1000); // 5 min
    
    return results;
};
```

---

**Decision Tree Created:** December 2, 2025  
**Status:** Ready for Developer Reference  
**Use:** When uncertain about query optimization approach

