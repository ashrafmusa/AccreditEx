# Firebase Free Tier Best Practices Guide

**For:** AccreditEx Development Team  
**Date:** January 15, 2025  
**Purpose:** Standardized patterns for efficient Firestore operations on free tier

## Table of Contents

1. [Efficient Queries](#efficient-queries)
2. [Caching Strategies](#caching-strategies)
3. [Pagination Patterns](#pagination-patterns)
4. [Error Handling](#error-handling)
5. [Quota Management](#quota-management)
6. [Performance Optimization](#performance-optimization)
7. [Quick Reference](#quick-reference)

---

## Efficient Queries

### ✅ DO: Use Database-Level Filtering

```typescript
// BAD: Get all, filter client-side
const allProjects = await getDocs(collection(db, 'projects'));
const filtered = allProjects.docs
  .map(doc => ({ id: doc.id, ...doc.data() }))
  .filter(p => p.status === 'Active');

// GOOD: Filter at database level
const q = query(
  collection(db, 'projects'),
  where('status', '==', 'Active'),
  limit(100)
);
const filtered = await getDocs(q);
```

**Cost:** 
- Bad: 1 read for full collection (500+ items = 1 read, all loaded to memory)
- Good: 1 read for filtered subset

### ✅ DO: Always Add Limits

```typescript
// Every query should have a limit to prevent accidents
const q = query(
  collection(db, 'projects'),
  limit(25) // Never fetch entire collections
);
```

### ✅ DO: Use Composite Indexes for Multi-Field Queries

```typescript
// Query with multiple conditions requires an index
// See COMPOSITE_INDEXES_GUIDE.md for setup
const q = query(
  collection(db, 'projects'),
  where('departmentId', '==', deptId),
  where('status', '==', 'Active'),
  orderBy('createdAt', 'desc'),
  limit(25)
);
```

### ✅ DO: Combine Filters with AND Logic

```typescript
// Good: All conditions must be true (narrows results)
const q = query(
  collection(db, 'users'),
  where('departmentId', '==', deptId),
  where('role', '==', 'Manager'),
  where('status', '==', 'Active')
);

// BAD: Multiple separate queries (wastes reads)
const query1 = query(collection(db, 'users'), where('departmentId', '==', deptId));
const query2 = query(collection(db, 'users'), where('role', '==', 'Manager'));
```

---

## Caching Strategies

### ✅ DO: Cache Repeated Queries

```typescript
import { firestoreCache } from '@/services/firestoreCache';

// First call: reads from Firestore (1 read)
const users = await firestoreCache.getCachedCollection<User>(
  'users',
  [where('departmentId', '==', deptId)]
);

// Second call within 5 minutes: cached (0 reads)
const usersAgain = await firestoreCache.getCachedCollection<User>(
  'users',
  [where('departmentId', '==', deptId)]
);

// Invalidate after mutations
await updateDoc(userRef, updates);
firestoreCache.invalidate('users');
```

**Expected Reduction:** 60-80% fewer reads for repeated queries

### ✅ DO: Implement Request Deduplication

```typescript
// When multiple components need same data
// Use a store/hook to prevent duplicate requests

// BAD: Each component fetches independently
// ComponentA: getDocs(usersQuery) → 1 read
// ComponentB: getDocs(usersQuery) → 1 read
// Total: 2 reads for same data

// GOOD: Single fetch via store
// useUserStore.getUsers() 
// ComponentA: uses store → 0 reads (already loaded)
// ComponentB: uses store → 0 reads (already loaded)
// Total: 1 read for both components
```

### ✅ DO: Use Appropriate Cache TTLs

```typescript
// Short-lived data (5 min default)
await firestoreCache.getCachedCollection('users'); // TTL: 5 min

// Long-lived data (30 min)
await firestoreCache.getCachedCollection('standards', [], 30 * 60 * 1000);

// Static data (never expires without invalidation)
await firestoreCache.getCachedCollection('departments', [], Infinity);
```

---

## Pagination Patterns

### ✅ DO: Always Paginate Large Collections

```typescript
import { queryOptimizer } from '@/services/queryOptimizer';

// First page
const result = await queryOptimizer.fetchPaginated('projects', {
  pageSize: 25,
  constraints: [where('status', '==', 'Active')]
});

console.log(result.data); // 25 items
console.log(result.hasNext); // true if more items exist

// Next page (cursor-based)
if (result.hasNext && result.nextCursor) {
  const nextResult = await queryOptimizer.fetchNextPage(
    'projects',
    result.nextCursor,
    { pageSize: 25 }
  );
}
```

**Cost Reduction:** 50-70% by loading only needed pages

### ✅ DO: Use Cursor-Based Pagination

```typescript
// Good: Cursor-based (efficient for large datasets)
// Page 1: documents 0-24
// Page 2: documents 25-49 (starts after doc 24)
// No offset, just start after last doc

const result = await queryOptimizer.fetchNextPage(
  'projects',
  lastDocument,
  { pageSize: 25 }
);

// BAD: Offset-based (requires reading skipped documents)
// Page 1: skip 0, read 0-24 (1 read)
// Page 2: skip 25, read 25-49 (1 read, must read all 50 docs)
// Page 100: skip 2475, read 2475-2499 (1 read, must read all 2500 docs)
```

### ✅ DO: Implement Infinite Scroll

```typescript
const [items, setItems] = useState<Project[]>([]);
const [cursor, setCursor] = useState<DocumentSnapshot | undefined>();
const [hasMore, setHasMore] = useState(true);

const loadMore = async () => {
  const result = cursor
    ? await queryOptimizer.fetchNextPage('projects', cursor)
    : await queryOptimizer.fetchPaginated('projects', { pageSize: 25 });

  setItems(prev => [...prev, ...result.data]);
  setCursor(result.nextCursor);
  setHasMore(result.hasNext);
};
```

---

## Error Handling

### ✅ DO: Use Error Handler for Retries

```typescript
import { errorHandler, retryableFirestoreCall } from '@/services/errorHandler';

// Automatic retry with exponential backoff
const result = await retryableFirestoreCall(
  () => getDocs(query(projectsCollection, where('status', '==', 'Active'))),
  'fetch-active-projects'
);

if (result.success) {
  const projects = result.data?.map(doc => ({...}));
} else {
  // User-friendly message
  showError(result.error.userMessage);
  
  // Check if retryable
  if (result.error.isRetryable) {
    // Already attempted retry, inform user
  }
}
```

### ✅ DO: Handle Network Errors

```typescript
import { errorHandler } from '@/services/errorHandler';

// Check network status
if (!errorHandler.isOnline()) {
  // Use cached data or show offline message
  showOfflineMessage();
  return cachedData;
}

// Setup network listener
const unsubscribe = errorHandler.setupNetworkListener((isOnline) => {
  if (isOnline) {
    syncPendingChanges();
  } else {
    showOfflineNotification();
  }
});
```

### ✅ DO: Handle Quota Exceeded

```typescript
try {
  await addDoc(collection(db, 'projects'), newProject);
  freeTierMonitor.recordWrite(1);
} catch (error) {
  if (error.code === 'resource-exhausted') {
    // Daily quota exceeded
    showError('Daily limit exceeded. Please try again tomorrow.');
  }
}
```

---

## Quota Management

### ✅ DO: Monitor Usage Daily

```typescript
// In app initialization or stores
import { freeTierMonitor } from '@/services/freeTierMonitor';

const stats = freeTierMonitor.getStats();
const hourly = freeTierMonitor.getHourlyRate();

if (hourly.willExceedFreeTier.reads) {
  console.warn('Current usage will exceed free tier this month');
  // Notify admins or enable restrictions
}

// Check warnings
const warnings = freeTierMonitor.getWarnings();
if (warnings.length > 0) {
  showNotification('Free tier usage warnings detected');
}
```

### ✅ DO: Implement Usage Dashboards

```typescript
// Settings → Usage Monitor (see components/settings/UsageMonitorPage.tsx)
// Shows:
// - Daily usage
// - Monthly progress
// - Projections
// - Export functionality
```

### ✅ DO: Set Up Alerts

```typescript
// Alert when approaching 80% limit
// Trigger: freeTierMonitor.getWarnings() returns warnings

// Alert when projection shows overage
// Trigger: hourly.willExceedFreeTier.reads === true

// Could integrate with:
// - Toast notifications
// - Email alerts
// - Slack webhooks
```

---

## Performance Optimization

### ✅ DO: Batch Operations

```typescript
// Get multiple collections efficiently
const results = await queryOptimizer.batchFetch<any>(
  ['projects', 'users', 'documents'],
  10 // max 10 items per collection
);

const projects = results.get('projects'); // Already limited
const users = results.get('users');
const documents = results.get('documents');
```

### ✅ DO: Use Offline Persistence

```typescript
// Automatic via firebase/firebaseConfig.ts
// enableIndexedDbPersistence(db) is already set up

// Benefits:
// - App works offline
// - Automatic syncing when reconnected
// - Reduces reads when data cached locally
// - No code needed, just works automatically
```

### ✅ DO: Optimize Component Re-renders

```typescript
// BAD: Triggers query on every render
export function ProjectList() {
  const [projects, setProjects] = useState([]);
  
  projects = fetchProjects(); // Runs every render!
  
  return <div>...</div>;
}

// GOOD: Use store/hook (memoized)
export function ProjectList() {
  const projects = useProjectStore(state => state.projects);
  
  return <div>...</div>;
}

// GOOD: Fetch once on mount
export function ProjectList() {
  const [projects, setProjects] = useState([]);
  
  useEffect(() => {
    fetchProjects().then(setProjects); // Runs once
  }, []);
  
  return <div>...</div>;
}
```

---

## Quick Reference

### Checklist Before Writing Queries

- [ ] **Is this a list?** → Use `limit(25)` for pagination
- [ ] **Need specific subset?** → Use `where()` filters at DB
- [ ] **Accessed repeatedly?** → Use `firestoreCache`
- [ ] **Multiple filters?** → Use AND conditions + index
- [ ] **Sorting needed?** → Use `orderBy()` at DB
- [ ] **Showing all results?** → Implement pagination
- [ ] **Offline support?** → Already enabled (IndexedDB)
- [ ] **Error handling?** → Use `retryableFirestoreCall`
- [ ] **Recording operation?** → Call `freeTierMonitor.recordRead/Write/Delete`

### Common Operations

```typescript
// Get paginated list with filtering
const result = await queryOptimizer.fetchPaginated('projects', {
  pageSize: 25,
  constraints: [where('status', '==', 'Active')]
});

// Get cached data
const users = await firestoreCache.getCachedCollection('users', 
  [where('departmentId', '==', deptId)]
);

// Search with limits
const results = await queryOptimizer.search('projects',
  [where('name', '>=', searchTerm), where('name', '<=', searchTerm + '\uf8ff')],
  50 // max results
);

// Handle errors
const result = await retryableFirestoreCall(
  () => getDocs(query(collection(db, 'projects'), limit(25))),
  'fetch-projects'
);

// Monitor usage
const stats = freeTierMonitor.getStats();
const warnings = freeTierMonitor.getWarnings();
```

### Cost Estimation

**Per User Activity:**
- View projects list: 1 read (paginated)
- View project details: 0 reads (cached from list)
- Create project: 1 write
- Update project: 1 write
- Search projects: 1 read (limited)
- View dashboard: 5-10 reads (all collections, paginated)

**Daily 50-User Activity:**
- 50 × 10 reads/user = 500 reads
- 50 × 2 writes/user = 100 writes
- **Total: 600 reads/day** ✅ Within free tier!

---

## Additional Resources

- [Firebase Best Practices](https://firebase.google.com/docs/firestore/best-practices)
- [Firestore Pricing](https://firebase.google.com/pricing)
- [COMPOSITE_INDEXES_GUIDE.md](./COMPOSITE_INDEXES_GUIDE.md)
- [USAGE_MONITORING_SETUP.md](./USAGE_MONITORING_SETUP.md)

---

**Maintenance Note:** Update this guide quarterly as new patterns emerge or tools are added.
